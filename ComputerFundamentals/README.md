# 计算机基础面试题

## HTTP/HTTPS
### 1、HTTP与HTTPS的区别

|  | HTTP | HTTPS |
|----|----|----|
| 定义 | HTTPS是一种通过计算机网络进行安全通信的传输协议 | HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份 认证，保护交换数据的隐私与完整性 |
| 默认端口 | :80 | :443 |
| 传输协议 | 超文本传输协议，属于明文传输 | 安全的超文本传输协议，是经过SSL加密后的传输协议 |

### 2、通信过程
#### HTTP的通信过程
作为标准的C/S模型，http协议总是由客户端发起，服务器进行响应。

1、DNS解析，域名系统DNS将域名解析成IP地址

2、建立TCP连接，进行TCP的三次握手

3、浏览器发送请求

4、服务器响应浏览器，向浏览器发送数据

5、通信完成，TCP连接关闭

#### HTTPS的通信过程
https通信是建立在ssl连接层之上的请求和响应，客户端将加密组件发送到服务端，服务端进行匹配后将数字证书等信息发送到客户端，客户端进行证书验证，验证通过后使用非对称加密对数据的密钥进行协商，协商后得到对称的加密密钥，然后使用对称算法进行TCP链接，然后与客户端进行三次握手后，进行数据传输，传输完成后，四次挥手，断开链接，通信结束。

#### 通信过程如下
1、客户端和服务器端通过TCP建立连接，并发送https请求。

2、服务器响应请求，并将数字证书发送给客户端，数字证书包括公共秘钥、域名、申请证书的公司。

3、客户端收到服务器端的数字证书之后，会验证数字证书的合法性。

4、如果公钥合格，那么客户端会生成client key，一个用于进行对称加密的密钥，并用服务器的公钥对客户端密钥进行非对称加密。

5、客户端会再次发起请求，将加密之后的客户端密钥发送给服务器。

6、服务器接收密文后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。

7、客户端收到密文，并使用客户端秘钥进行解密，获取数据。

>加密算法的类型基本上分为了两种：
>- 对称加密，加密用的密钥和解密用的密钥是同一个，比较有代表性的就是 AES 加密算法；
>- 非对称加密，加密用的密钥称为公钥，解密用的密钥称为私钥，经常使用到的 RSA 加密算法就是非对称加密的；

>相比较对称加密而言，非对称加密安全性更高，但是加解密耗费的时间更长，速度慢。

![image](https://raw.githubusercontent.com/v1ncent9527/AndroidInterview/main/Snapshot/https_communication_process.webp)

### 3、响应码
1**	信息，服务器收到请求，需要请求者继续执行操作

2**	成功，操作被成功接收并处理

3**	重定向，需要进一步的操作以完成请求

4**	客户端错误，请求包含语法错误或无法完成请求

5**	服务器错误，服务器在处理请求的过程中发生了错误


## TCP/UDP

### 1、大白话告诉你 TCP 为什么需要三次握手四次挥手

#### 三次握手

![image](https://raw.githubusercontent.com/v1ncent9527/AndroidInterview/main/Snapshot/three_handshakes.webp)

- 1、刚开始客户端和服务端都是处于关闭的状态，而且服务器 B 端一直处于监听的状态，时刻监听是否有建立连接的请求；

- 2、当有客户端需要建立连接的时候就会发送一个确定连接的报文，此报文是同步报文SYN = 1，并且会生成一个随机的序号 seq = x，这是第一次握手；

- 3、当服务端接收到请求连接报文的时候，会发送一个同步报文确认报文，此报文 SYN = 1，并且 ACK = 1，同时服务端也会随机生成一个 seq = y，并将 ack 设置成 x + 1，回传给客户端，这是第二次握手；

- 4、当客户端接收到服务端的 ACK 报文后，会回复一个 ACK 确认报文，用于确认确认报文已经收到，此报文 ACK = 1，seq = x + 1, ack = y + 1，这是第三次握手；

> 这里有个点说明一下：大写的 ACK 表示报文的类型是确认报文，小写的 ack 是报文里面的确认号，这个确认号是上一次握手对方的 seq 值加 1 得到。

上面是整个三次握手的过程，现在我们分析一下为什么三次握手可以可靠的确定客户端和服务端都能支持的发送和接收数据。

第一次握手：第一次握手是客户端发送同步报文到服务端，这个时候客户端是知道自己具备发送数据的能力的，但是不知道服务端是否有接收和发送数据的能力；

第二次握手：当服务端接收到同步报文后，回复确认同步报文，此时服务端是知道客户端具有发送报文的能力，并且知道自己具有接收和发送数据的能力，但是并不知道客户端是否有接收数据的能力；

第三次握手：当客户端收到服务端的确认报文后，知道服务端具备接收和发送数据的能力，但是此时服务端并不知道自己具有接收的能力，所以还需要发送一个确认报文，告知服务端自己是具有接收能力的。

当整个三次握手结束过后，客户端和服务端都知道自己和对方具备发送和接收数据的能力，随后整个连接建立就完成了，可以进行后续数据的传输了。

看到这里，如果大家理解了就会知道很明显，两次握手是不行的，因为服务端并不知道客户端是具备接收数据的能力，所以就不能成为面向连接的可靠的传输协议。就像我们上面提到的打电话的例子，也是为了双方能够正常的进行交流，只不过我们现实生活中不会那么严谨，并不是每次都这样，但是程序是不一样的。

#### 四次挥手

![image](https://raw.githubusercontent.com/v1ncent9527/AndroidInterview/main/Snapshot/four_waves.webp)

- 1、客户端发起 FIN 断开连接的报文，携带随机生成的 seq 值 u，发送给服务端，并且自己处于 FIN-WSIT 状态，这是第一次挥手；

- 2、服务端接收到 FIN 报文后，回复一个确认报文，其中 ACK = 1，随机生成一个 seq，以及 ack = u + 1，这是第二次挥手；

- 3、当服务端数据发送完了过后，再发送一个 FIN 报文给客户端，通知客户端，服务端准备关闭连接了，此报文 FIN = 1，ACK = 1，ack = u + 1，seq = w，这是第三次挥手；

- 4、当客户端收到 FIN 确认报文时再发送一个FIN 的确认报文，其中 ACK = 1，seq = u + 1，ack = w + 1，并进入 TIME-WAIT 状态，当等待 2MSL 后关闭连接，这是第四次挥手。


第一次挥手客户端发起关闭连接的请求给服务端；

第二次挥手：服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但是因为数据还没传输完，所以还需要等待；

第三次挥手：当数据传输完了，服务端会主动发送一个 FIN 报文，告诉客户端，表示数据已经发送完了，服务端这边准备关闭连接了。

第四次挥手：当客户端收到服务端的 FIN 报文过后，会回复一个 ACK 报文，告诉服务端自己知道了，再等待一会就关闭连接。

#### 疑问
1、为什么握手要三次，挥手却要四次呢？

>那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候有数据在传输，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。

2、为什么客户端在第四次挥手后还会等待 2MSL？

>等待 2MSL 是因为保证服务端接收到了 ACK 报文，因为网络是复杂了，很有可能 ACK 报文丢失了，如果服务端没接收到 ACK 报文的话，会重新发送 FIN 报文，只有当客户端等待了 2MSL 都没有收到重发的 FIN 报文时就表示服务端是正常收到了 ACK 报文，那么这个时候客户端就可以关闭了。

### 2、TCP/UDP的区别
1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。